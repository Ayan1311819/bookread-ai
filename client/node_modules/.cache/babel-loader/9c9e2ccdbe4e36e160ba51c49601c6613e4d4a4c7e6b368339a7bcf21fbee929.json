{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nimport { jsx, jsxs } from \"react/jsx-runtime\";\nimport React, { Component, PureComponent } from \"react\";\nimport Epub from \"epubjs\";\nimport { useSwipeable } from \"react-swipeable\";\nconst EpubViewStyle = {\n  viewHolder: {\n    position: \"relative\",\n    height: \"100%\",\n    width: \"100%\"\n  },\n  view: {\n    height: \"100%\"\n  }\n};\nclass EpubView extends Component {\n  constructor(props) {\n    super(props);\n    __publicField(this, \"state\", {\n      isLoaded: false,\n      toc: []\n    });\n    __publicField(this, \"viewerRef\", React.createRef());\n    __publicField(this, \"location\");\n    __publicField(this, \"book\");\n    __publicField(this, \"rendition\");\n    __publicField(this, \"prevPage\");\n    __publicField(this, \"nextPage\");\n    __publicField(this, \"onLocationChange\", loc => {\n      const {\n        location,\n        locationChanged\n      } = this.props;\n      const newLocation = `${loc.start}`;\n      if (location !== newLocation) {\n        this.location = newLocation;\n        locationChanged && locationChanged(newLocation);\n      }\n    });\n    __publicField(this, \"handleKeyPress\", event => {\n      if (event.key === \"ArrowRight\" && this.nextPage) {\n        this.nextPage();\n      }\n      if (event.key === \"ArrowLeft\" && this.prevPage) {\n        this.prevPage();\n      }\n    });\n    this.location = props.location;\n    this.book = this.rendition = this.prevPage = this.nextPage = void 0;\n  }\n  componentDidMount() {\n    this.initBook();\n    document.addEventListener(\"keyup\", this.handleKeyPress, false);\n  }\n  initBook() {\n    const {\n      url,\n      tocChanged,\n      epubInitOptions\n    } = this.props;\n    if (this.book) {\n      this.book.destroy();\n    }\n    this.book = Epub(url, epubInitOptions);\n    this.book.loaded.navigation.then(({\n      toc\n    }) => {\n      this.setState({\n        isLoaded: true,\n        toc\n      }, () => {\n        tocChanged && tocChanged(toc);\n        this.initReader();\n      });\n    });\n  }\n  componentWillUnmount() {\n    if (this.book) {\n      this.book.destroy();\n    }\n    this.book = this.rendition = this.prevPage = this.nextPage = void 0;\n    document.removeEventListener(\"keyup\", this.handleKeyPress, false);\n  }\n  shouldComponentUpdate(nextProps) {\n    return !this.state.isLoaded || nextProps.location !== this.props.location || nextProps.url !== this.props.url;\n  }\n  componentDidUpdate(prevProps) {\n    var _a;\n    if (prevProps.location !== this.props.location && this.location !== this.props.location) {\n      (_a = this.rendition) == null ? void 0 : _a.display(this.props.location + \"\");\n    }\n    if (prevProps.url !== this.props.url) {\n      this.initBook();\n    }\n  }\n  initReader() {\n    const {\n      toc\n    } = this.state;\n    const {\n      location,\n      epubOptions,\n      getRendition\n    } = this.props;\n    if (this.viewerRef.current) {\n      const node = this.viewerRef.current;\n      if (this.book) {\n        const rendition = this.book.renderTo(node, {\n          width: \"100%\",\n          height: \"100%\",\n          ...epubOptions\n        });\n        this.rendition = rendition;\n        this.prevPage = () => {\n          rendition.prev();\n        };\n        this.nextPage = () => {\n          rendition.next();\n        };\n        this.registerEvents();\n        getRendition && getRendition(rendition);\n        if (typeof location === \"string\" || typeof location === \"number\") {\n          rendition.display(location + \"\");\n        } else if (toc.length > 0 && toc[0].href) {\n          rendition.display(toc[0].href);\n        } else {\n          rendition.display();\n        }\n      }\n    }\n  }\n  registerEvents() {\n    const {\n      handleKeyPress,\n      handleTextSelected\n    } = this.props;\n    if (this.rendition) {\n      this.rendition.on(\"locationChanged\", this.onLocationChange);\n      this.rendition.on(\"keyup\", handleKeyPress || this.handleKeyPress);\n      if (handleTextSelected) {\n        this.rendition.on(\"selected\", handleTextSelected);\n      }\n    }\n  }\n  renderBook() {\n    const {\n      epubViewStyles = EpubViewStyle\n    } = this.props;\n    return /* @__PURE__ */jsx(\"div\", {\n      ref: this.viewerRef,\n      style: epubViewStyles.view\n    });\n  }\n  render() {\n    const {\n      isLoaded\n    } = this.state;\n    const {\n      loadingView = null,\n      epubViewStyles = EpubViewStyle\n    } = this.props;\n    return /* @__PURE__ */jsx(\"div\", {\n      style: epubViewStyles.viewHolder,\n      children: isLoaded && this.renderBook() || loadingView\n    });\n  }\n}\nconst ReactReaderStyle = {\n  container: {\n    overflow: \"hidden\",\n    position: \"relative\",\n    height: \"100%\"\n  },\n  readerArea: {\n    position: \"relative\",\n    zIndex: 1,\n    height: \"100%\",\n    width: \"100%\",\n    backgroundColor: \"#fff\",\n    transition: \"all .3s ease\"\n  },\n  containerExpanded: {\n    transform: \"translateX(256px)\"\n  },\n  titleArea: {\n    position: \"absolute\",\n    top: 20,\n    left: 50,\n    right: 50,\n    textAlign: \"center\",\n    color: \"#999\"\n  },\n  reader: {\n    position: \"absolute\",\n    top: 50,\n    left: 50,\n    bottom: 20,\n    right: 50\n  },\n  swipeWrapper: {\n    position: \"absolute\",\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0,\n    zIndex: 200\n  },\n  prev: {\n    left: 1\n  },\n  next: {\n    right: 1\n  },\n  arrow: {\n    outline: \"none\",\n    border: \"none\",\n    background: \"none\",\n    position: \"absolute\",\n    top: \"50%\",\n    marginTop: -32,\n    fontSize: 64,\n    padding: \"0 10px\",\n    color: \"#E2E2E2\",\n    fontFamily: \"arial, sans-serif\",\n    cursor: \"pointer\",\n    userSelect: \"none\",\n    appearance: \"none\",\n    fontWeight: \"normal\"\n  },\n  arrowHover: {\n    color: \"#777\"\n  },\n  toc: {},\n  tocBackground: {\n    position: \"absolute\",\n    left: 256,\n    top: 0,\n    bottom: 0,\n    right: 0,\n    zIndex: 1\n  },\n  tocArea: {\n    position: \"absolute\",\n    left: 0,\n    top: 0,\n    bottom: 0,\n    zIndex: 0,\n    width: 256,\n    overflowY: \"auto\",\n    WebkitOverflowScrolling: \"touch\",\n    background: \"#f2f2f2\",\n    padding: \"10px 0\"\n  },\n  tocAreaButton: {\n    userSelect: \"none\",\n    appearance: \"none\",\n    background: \"none\",\n    border: \"none\",\n    display: \"block\",\n    fontFamily: \"sans-serif\",\n    width: \"100%\",\n    fontSize: \".9em\",\n    textAlign: \"left\",\n    padding: \".9em 1em\",\n    borderBottom: \"1px solid #ddd\",\n    color: \"#aaa\",\n    boxSizing: \"border-box\",\n    outline: \"none\",\n    cursor: \"pointer\"\n  },\n  tocButton: {\n    background: \"none\",\n    border: \"none\",\n    width: 32,\n    height: 32,\n    position: \"absolute\",\n    top: 10,\n    left: 10,\n    borderRadius: 2,\n    outline: \"none\",\n    cursor: \"pointer\"\n  },\n  tocButtonExpanded: {\n    background: \"#f2f2f2\"\n  },\n  tocButtonBar: {\n    position: \"absolute\",\n    width: \"60%\",\n    background: \"#ccc\",\n    height: 2,\n    left: \"50%\",\n    margin: \"-1px -30%\",\n    top: \"50%\",\n    transition: \"all .5s ease\"\n  },\n  tocButtonBarTop: {\n    top: \"35%\"\n  },\n  tocButtonBottom: {\n    top: \"66%\"\n  },\n  loadingView: {\n    position: \"absolute\",\n    top: \"50%\",\n    left: \"10%\",\n    right: \"10%\",\n    color: \"#ccc\",\n    textAlign: \"center\",\n    marginTop: \"-.5em\"\n  }\n};\nconst SwipeWrapper = ({\n  children,\n  swipeProps\n}) => {\n  const handlers = useSwipeable(swipeProps);\n  return /* @__PURE__ */jsx(\"div\", {\n    style: {\n      height: \"100%\"\n    },\n    ...handlers,\n    children\n  });\n};\nconst TocItem = ({\n  data,\n  setLocation,\n  styles\n}) => /* @__PURE__ */jsxs(\"div\", {\n  children: [/* @__PURE__ */jsx(\"button\", {\n    onClick: () => setLocation(data.href),\n    style: styles,\n    children: data.label\n  }), data.subitems && data.subitems.length > 0 && /* @__PURE__ */jsx(\"div\", {\n    style: {\n      paddingLeft: 10\n    },\n    children: data.subitems.map((item, i) => /* @__PURE__ */jsx(TocItem, {\n      data: item,\n      styles,\n      setLocation\n    }, i))\n  })]\n});\nclass ReactReader extends PureComponent {\n  constructor(props) {\n    super(props);\n    __publicField(this, \"state\", {\n      isLoaded: false,\n      expandedToc: false,\n      toc: []\n    });\n    __publicField(this, \"readerRef\", React.createRef());\n    __publicField(this, \"toggleToc\", () => {\n      this.setState({\n        expandedToc: !this.state.expandedToc\n      });\n    });\n    __publicField(this, \"next\", () => {\n      const node = this.readerRef.current;\n      if (node && node.nextPage) {\n        node.nextPage();\n      }\n    });\n    __publicField(this, \"prev\", () => {\n      const node = this.readerRef.current;\n      if (node && node.prevPage) {\n        node.prevPage();\n      }\n    });\n    __publicField(this, \"onTocChange\", toc => {\n      const {\n        tocChanged\n      } = this.props;\n      this.setState({\n        toc\n      }, () => tocChanged && tocChanged(toc));\n    });\n    __publicField(this, \"setLocation\", loc => {\n      const {\n        locationChanged\n      } = this.props;\n      this.setState({\n        expandedToc: false\n      }, () => locationChanged && locationChanged(loc));\n    });\n    // Changing Page based on direction of scroll\n    __publicField(this, \"handleWheel\", event => {\n      var _a, _b;\n      event.preventDefault();\n      const node = this.readerRef.current;\n      if (!node) return;\n      if (event.deltaY > 0) {\n        (_a = node.nextPage) == null ? void 0 : _a.call(node);\n      } else if (event.deltaY < 0) {\n        (_b = node.prevPage) == null ? void 0 : _b.call(node);\n      }\n    });\n    // Setting up event listener in the iframe of the viewer\n    __publicField(this, \"attachWheelListener\", () => {\n      if (!this.readerRef.current) return;\n      const rendition = this.readerRef.current.rendition;\n      if (rendition) {\n        rendition.hooks.content.register(contents => {\n          const iframeDoc = contents.window.document;\n          iframeDoc.removeEventListener(\"wheel\", this.handleWheel);\n          iframeDoc.addEventListener(\"wheel\", this.handleWheel, {\n            passive: false\n          });\n        });\n      }\n    });\n    //search function to find all occurence and set amount of charecters for context\n    __publicField(this, \"searchInBook\", async query => {\n      var _a, _b, _c, _d, _e;\n      if (!this.readerRef.current) return;\n      const rendition = (_a = this.readerRef.current) == null ? void 0 : _a.rendition;\n      const book = rendition == null ? void 0 : rendition.book;\n      if (!book) return;\n      if (!query) {\n        (_c = (_b = this.props).onSearchResults) == null ? void 0 : _c.call(_b, []);\n        return;\n      }\n      await book.ready;\n      const results = [];\n      const promises = [];\n      book.spine.each(item => {\n        const promise = (async () => {\n          try {\n            await item.load(book.load.bind(book));\n            const doc = item.document;\n            const textNodes = [];\n            const treeWalker = doc.createTreeWalker(doc, NodeFilter.SHOW_TEXT, null, false);\n            let node;\n            while (node = treeWalker.nextNode()) {\n              textNodes.push(node);\n            }\n            const fullText = textNodes.map(n => n.textContent).join(\"\").toLowerCase();\n            const searchQuery = query.toLowerCase();\n            let pos = fullText.indexOf(searchQuery);\n            while (pos !== -1) {\n              let nodeIndex = 0;\n              let foundOffset = pos;\n              while (nodeIndex < textNodes.length) {\n                const nodeText = textNodes[nodeIndex].textContent || \"\";\n                if (foundOffset < nodeText.length) break;\n                foundOffset -= nodeText.length;\n                nodeIndex++;\n              }\n              if (nodeIndex < textNodes.length) {\n                let range = doc.createRange();\n                try {\n                  range.setStart(textNodes[nodeIndex], foundOffset);\n                  range.setEnd(textNodes[nodeIndex], foundOffset + searchQuery.length);\n                  const cfi = item.cfiFromRange(range);\n                  const excerpt = `${fullText.substring(Math.max(0, pos - (this.props.contextLength || 15)), pos + searchQuery.length + (this.props.contextLength || 15))}`;\n                  results.push({\n                    cfi,\n                    excerpt\n                  });\n                } catch (e) {\n                  console.warn(\"Skipping invalid range:\", e);\n                }\n              }\n              pos = fullText.indexOf(searchQuery, pos + 1);\n            }\n            item.unload();\n          } catch (error) {\n            console.error(\"Error searching chapter:\", error);\n          }\n        })();\n        promises.push(promise);\n      });\n      await Promise.all(promises);\n      if (query == this.props.searchQuery) {\n        (_e = (_d = this.props).onSearchResults) == null ? void 0 : _e.call(_d, results);\n      }\n    });\n  }\n  renderToc() {\n    const {\n      toc,\n      expandedToc\n    } = this.state;\n    const {\n      readerStyles = ReactReaderStyle\n    } = this.props;\n    return /* @__PURE__ */jsxs(\"div\", {\n      children: [/* @__PURE__ */jsx(\"div\", {\n        style: readerStyles.tocArea,\n        children: /* @__PURE__ */jsx(\"div\", {\n          style: readerStyles.toc,\n          children: toc.map((item, i) => /* @__PURE__ */jsx(TocItem, {\n            data: item,\n            setLocation: this.setLocation,\n            styles: readerStyles.tocAreaButton\n          }, i))\n        })\n      }), expandedToc && /* @__PURE__ */jsx(\"div\", {\n        style: readerStyles.tocBackground,\n        onClick: this.toggleToc\n      })]\n    });\n  }\n  renderTocToggle() {\n    const {\n      expandedToc\n    } = this.state;\n    const {\n      readerStyles = ReactReaderStyle\n    } = this.props;\n    return /* @__PURE__ */jsxs(\"button\", {\n      style: Object.assign({}, readerStyles.tocButton, expandedToc ? readerStyles.tocButtonExpanded : {}),\n      onClick: this.toggleToc,\n      children: [/* @__PURE__ */jsx(\"span\", {\n        style: Object.assign({}, readerStyles.tocButtonBar, readerStyles.tocButtonBarTop)\n      }), /* @__PURE__ */jsx(\"span\", {\n        style: Object.assign({}, readerStyles.tocButtonBar, readerStyles.tocButtonBottom)\n      })]\n    });\n  }\n  //Actions to perform when the component updates\n  componentDidUpdate(prevProps) {\n    if (prevProps.searchQuery !== this.props.searchQuery) {\n      this.searchInBook(this.props.searchQuery);\n    }\n    if (this.props.pageTurnOnScroll === true) {\n      this.attachWheelListener();\n    }\n  }\n  render() {\n    const {\n      title,\n      showToc = true,\n      loadingView,\n      readerStyles = ReactReaderStyle,\n      locationChanged,\n      swipeable,\n      epubViewStyles,\n      isRTL = false,\n      pageTurnOnScroll = false,\n      searchQuery,\n      contextLength,\n      ...props\n    } = this.props;\n    const {\n      toc,\n      expandedToc\n    } = this.state;\n    return /* @__PURE__ */jsxs(\"div\", {\n      style: readerStyles.container,\n      children: [/* @__PURE__ */jsxs(\"div\", {\n        style: Object.assign({}, readerStyles.readerArea, expandedToc ? readerStyles.containerExpanded : {}),\n        children: [showToc && this.renderTocToggle(), /* @__PURE__ */jsx(\"div\", {\n          style: readerStyles.titleArea,\n          children: title\n        }), /* @__PURE__ */jsx(SwipeWrapper, {\n          swipeProps: {\n            onSwiped: eventData => {\n              const {\n                dir\n              } = eventData;\n              if (dir === \"Left\") {\n                isRTL ? this.prev() : this.next();\n              }\n              if (dir === \"Right\") {\n                isRTL ? this.next() : this.prev();\n              }\n            },\n            onTouchStartOrOnMouseDown: ({\n              event\n            }) => event.preventDefault(),\n            touchEventOptions: {\n              passive: false\n            },\n            preventScrollOnSwipe: true,\n            trackMouse: true\n          },\n          children: /* @__PURE__ */jsxs(\"div\", {\n            style: readerStyles.reader,\n            children: [/* @__PURE__ */jsx(EpubView, {\n              ref: this.readerRef,\n              loadingView: loadingView === void 0 ? /* @__PURE__ */jsx(\"div\", {\n                style: readerStyles.loadingView,\n                children: \"Loading…\"\n              }) : loadingView,\n              epubViewStyles,\n              ...props,\n              tocChanged: this.onTocChange,\n              locationChanged\n            }), swipeable && /* @__PURE__ */jsx(\"div\", {\n              style: readerStyles.swipeWrapper\n            })]\n          })\n        }), /* @__PURE__ */jsx(\"button\", {\n          style: Object.assign({}, readerStyles.arrow, readerStyles.prev),\n          onClick: isRTL ? this.next : this.prev,\n          children: \"‹\"\n        }), /* @__PURE__ */jsx(\"button\", {\n          style: Object.assign({}, readerStyles.arrow, readerStyles.next),\n          onClick: isRTL ? this.prev : this.next,\n          children: \"›\"\n        })]\n      }), showToc && toc && this.renderToc()]\n    });\n  }\n}\nexport { EpubView, EpubViewStyle, ReactReader, ReactReaderStyle };","map":{"version":3,"names":["EpubViewStyle","viewHolder","position","height","width","view","EpubView","Component","constructor","props","__publicField","isLoaded","toc","React","createRef","loc","location","locationChanged","newLocation","start","event","key","nextPage","prevPage","book","rendition","componentDidMount","initBook","document","addEventListener","handleKeyPress","url","tocChanged","epubInitOptions","destroy","Epub","loaded","navigation","then","setState","initReader","componentWillUnmount","removeEventListener","shouldComponentUpdate","nextProps","state","componentDidUpdate","prevProps","_a","display","epubOptions","getRendition","viewerRef","current","node","renderTo","prev","next","registerEvents","length","href","handleTextSelected","on","onLocationChange","renderBook","epubViewStyles","jsx","ref","style","render","loadingView","children","ReactReaderStyle","container","overflow","readerArea","zIndex","backgroundColor","transition","containerExpanded","transform","titleArea","top","left","right","textAlign","color","reader","bottom","swipeWrapper","arrow","outline","border","background","marginTop","fontSize","padding","fontFamily","cursor","userSelect","appearance","fontWeight","arrowHover","tocBackground","tocArea","overflowY","WebkitOverflowScrolling","tocAreaButton","borderBottom","boxSizing","tocButton","borderRadius","tocButtonExpanded","tocButtonBar","margin","tocButtonBarTop","tocButtonBottom","SwipeWrapper","swipeProps","handlers","useSwipeable","TocItem","data","setLocation","styles","jsxs","onClick","label","subitems","paddingLeft","map","item","i","ReactReader","PureComponent","expandedToc","readerRef","preventDefault","deltaY","call","_b","hooks","content","register","contents","iframeDoc","window","handleWheel","passive","query","_c","onSearchResults","ready","results","promises","spine","each","promise","load","bind","doc","textNodes","treeWalker","createTreeWalker","NodeFilter","SHOW_TEXT","nextNode","push","fullText","n","textContent","join","toLowerCase","searchQuery","pos","indexOf","nodeIndex","foundOffset","nodeText","range","createRange","setStart","setEnd","cfi","cfiFromRange","excerpt","substring","Math","max","contextLength","e","console","warn","unload","error","Promise","all","_e","_d","renderToc","readerStyles","toggleToc","renderTocToggle","Object","assign","searchInBook","pageTurnOnScroll","attachWheelListener","title","showToc","swipeable","isRTL","onSwiped","eventData","dir","onTouchStartOrOnMouseDown","touchEventOptions","preventScrollOnSwipe","trackMouse","onTocChange"],"sources":["C:\\Users\\Hp\\OneDrive\\Desktop\\bookread-ai\\client\\node_modules\\react-reader\\lib\\EpubView\\style.ts","C:\\Users\\Hp\\OneDrive\\Desktop\\bookread-ai\\client\\node_modules\\react-reader\\lib\\EpubView\\EpubView.tsx","C:\\Users\\Hp\\OneDrive\\Desktop\\bookread-ai\\client\\node_modules\\react-reader\\lib\\ReactReader\\style.ts","C:\\Users\\Hp\\OneDrive\\Desktop\\bookread-ai\\client\\node_modules\\react-reader\\lib\\ReactReader\\ReactReader.tsx"],"sourcesContent":["import type { CSSProperties } from 'react'\n\nexport interface IEpubViewStyle {\n  viewHolder: CSSProperties\n  view: CSSProperties\n}\n\nexport const EpubViewStyle: IEpubViewStyle = {\n  viewHolder: {\n    position: 'relative',\n    height: '100%',\n    width: '100%',\n  },\n  view: {\n    height: '100%',\n  },\n}\n","import React, { Component } from 'react'\nimport Epub, { Book } from 'epubjs'\nimport type { NavItem, Contents, Rendition, Location } from 'epubjs'\nimport { EpubViewStyle as defaultStyles, type IEpubViewStyle } from './style'\nimport type { RenditionOptions } from 'epubjs/types/rendition'\nimport type { BookOptions } from 'epubjs/types/book'\n\nexport type RenditionOptionsFix = RenditionOptions & {\n  allowPopups: boolean\n}\n\nexport type IToc = {\n  label: string\n  href: string\n}\n\nexport type IEpubViewProps = {\n  url: string | ArrayBuffer\n  epubInitOptions?: Partial<BookOptions>\n  epubOptions?: Partial<RenditionOptionsFix>\n  epubViewStyles?: IEpubViewStyle\n  loadingView?: React.ReactNode\n  location: string | number | null\n  locationChanged(value: string): void\n  showToc?: boolean\n  tocChanged?(value: NavItem[]): void\n  getRendition?(rendition: Rendition): void\n  handleKeyPress?(): void\n  handleTextSelected?(cfiRange: string, contents: Contents): void\n}\ntype IEpubViewState = {\n  isLoaded: boolean\n  toc: NavItem[]\n}\n\nexport class EpubView extends Component<IEpubViewProps, IEpubViewState> {\n  state: Readonly<IEpubViewState> = {\n    isLoaded: false,\n    toc: [],\n  }\n  viewerRef = React.createRef<HTMLDivElement>()\n  location?: string | number | null\n  book?: Book\n  rendition?: Rendition\n  prevPage?: () => void\n  nextPage?: () => void\n\n  constructor(props: IEpubViewProps) {\n    super(props)\n    this.location = props.location\n    this.book = this.rendition = this.prevPage = this.nextPage = undefined\n  }\n\n  componentDidMount() {\n    this.initBook()\n    document.addEventListener('keyup', this.handleKeyPress, false)\n  }\n\n  initBook() {\n    const { url, tocChanged, epubInitOptions } = this.props\n    if (this.book) {\n      this.book.destroy()\n    }\n    this.book = Epub(url, epubInitOptions)\n    this.book.loaded.navigation.then(({ toc }) => {\n      this.setState(\n        {\n          isLoaded: true,\n          toc: toc,\n        },\n        () => {\n          tocChanged && tocChanged(toc)\n          this.initReader()\n        }\n      )\n    })\n  }\n\n  componentWillUnmount() {\n    if (this.book) {\n      this.book.destroy()\n    }\n    this.book = this.rendition = this.prevPage = this.nextPage = undefined\n    document.removeEventListener('keyup', this.handleKeyPress, false)\n  }\n\n  shouldComponentUpdate(nextProps: IEpubViewProps) {\n    return (\n      !this.state.isLoaded ||\n      nextProps.location !== this.props.location ||\n      nextProps.url !== this.props.url\n    )\n  }\n\n  componentDidUpdate(prevProps: IEpubViewProps) {\n    if (\n      prevProps.location !== this.props.location &&\n      this.location !== this.props.location\n    ) {\n      this.rendition?.display(this.props.location + '')\n    }\n    if (prevProps.url !== this.props.url) {\n      this.initBook()\n    }\n  }\n\n  initReader() {\n    const { toc } = this.state\n    const { location, epubOptions, getRendition } = this.props\n    if (this.viewerRef.current) {\n      const node = this.viewerRef.current\n      if (this.book) {\n        const rendition = this.book.renderTo(node, {\n          width: '100%',\n          height: '100%',\n          ...epubOptions,\n        })\n        this.rendition = rendition\n        this.prevPage = () => {\n          rendition.prev()\n        }\n        this.nextPage = () => {\n          rendition.next()\n        }\n        this.registerEvents()\n        getRendition && getRendition(rendition)\n\n        if (typeof location === 'string' || typeof location === 'number') {\n          rendition.display(location + '')\n        } else if (toc.length > 0 && toc[0].href) {\n          rendition.display(toc[0].href)\n        } else {\n          rendition.display()\n        }\n      }\n    }\n  }\n\n  registerEvents() {\n    const { handleKeyPress, handleTextSelected } = this.props\n    if (this.rendition) {\n      this.rendition.on('locationChanged', this.onLocationChange)\n      this.rendition.on('keyup', handleKeyPress || this.handleKeyPress)\n      if (handleTextSelected) {\n        this.rendition.on('selected', handleTextSelected)\n      }\n    }\n  }\n\n  onLocationChange = (loc: Location) => {\n    const { location, locationChanged } = this.props\n    const newLocation = `${loc.start}`\n    if (location !== newLocation) {\n      this.location = newLocation\n      locationChanged && locationChanged(newLocation)\n    }\n  }\n\n  renderBook() {\n    const { epubViewStyles = defaultStyles } = this.props\n    return <div ref={this.viewerRef} style={epubViewStyles.view} />\n  }\n\n  handleKeyPress = (event: KeyboardEvent) => {\n    if (event.key === 'ArrowRight' && this.nextPage) {\n      this.nextPage()\n    }\n    if (event.key === 'ArrowLeft' && this.prevPage) {\n      this.prevPage()\n    }\n  }\n\n  render() {\n    const { isLoaded } = this.state\n    const { loadingView = null, epubViewStyles = defaultStyles } = this.props\n    return (\n      <div style={epubViewStyles.viewHolder}>\n        {(isLoaded && this.renderBook()) || loadingView}\n      </div>\n    )\n  }\n}\n","import type { CSSProperties } from 'react'\n\nexport interface IReactReaderStyle {\n  container: CSSProperties\n  readerArea: CSSProperties\n  containerExpanded: CSSProperties\n  titleArea: CSSProperties\n  reader: CSSProperties\n  swipeWrapper: CSSProperties\n  prev: CSSProperties\n  next: CSSProperties\n  arrow: CSSProperties\n  arrowHover: CSSProperties\n  tocBackground: CSSProperties\n  toc: CSSProperties\n  tocArea: CSSProperties\n  tocAreaButton: CSSProperties\n  tocButton: CSSProperties\n  tocButtonExpanded: CSSProperties\n  tocButtonBar: CSSProperties\n  tocButtonBarTop: CSSProperties\n  loadingView: CSSProperties\n  tocButtonBottom: CSSProperties\n}\n\nexport const ReactReaderStyle: IReactReaderStyle = {\n  container: {\n    overflow: 'hidden',\n    position: 'relative',\n    height: '100%',\n  },\n  readerArea: {\n    position: 'relative',\n    zIndex: 1,\n    height: '100%',\n    width: '100%',\n    backgroundColor: '#fff',\n    transition: 'all .3s ease',\n  },\n  containerExpanded: {\n    transform: 'translateX(256px)',\n  },\n  titleArea: {\n    position: 'absolute',\n    top: 20,\n    left: 50,\n    right: 50,\n    textAlign: 'center',\n    color: '#999',\n  },\n  reader: {\n    position: 'absolute',\n    top: 50,\n    left: 50,\n    bottom: 20,\n    right: 50,\n  },\n  swipeWrapper: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0,\n    zIndex: 200,\n  },\n  prev: {\n    left: 1,\n  },\n  next: {\n    right: 1,\n  },\n  arrow: {\n    outline: 'none',\n    border: 'none',\n    background: 'none',\n    position: 'absolute',\n    top: '50%',\n    marginTop: -32,\n    fontSize: 64,\n    padding: '0 10px',\n    color: '#E2E2E2',\n    fontFamily: 'arial, sans-serif',\n    cursor: 'pointer',\n    userSelect: 'none',\n    appearance: 'none',\n    fontWeight: 'normal',\n  },\n  arrowHover: {\n    color: '#777',\n  },\n  toc: {},\n  tocBackground: {\n    position: 'absolute',\n    left: 256,\n    top: 0,\n    bottom: 0,\n    right: 0,\n    zIndex: 1,\n  },\n  tocArea: {\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    bottom: 0,\n    zIndex: 0,\n    width: 256,\n    overflowY: 'auto',\n    WebkitOverflowScrolling: 'touch',\n    background: '#f2f2f2',\n    padding: '10px 0',\n  },\n  tocAreaButton: {\n    userSelect: 'none',\n    appearance: 'none',\n    background: 'none',\n    border: 'none',\n    display: 'block',\n    fontFamily: 'sans-serif',\n    width: '100%',\n    fontSize: '.9em',\n    textAlign: 'left',\n    padding: '.9em 1em',\n    borderBottom: '1px solid #ddd',\n    color: '#aaa',\n    boxSizing: 'border-box',\n    outline: 'none',\n    cursor: 'pointer',\n  },\n  tocButton: {\n    background: 'none',\n    border: 'none',\n    width: 32,\n    height: 32,\n    position: 'absolute',\n    top: 10,\n    left: 10,\n    borderRadius: 2,\n    outline: 'none',\n    cursor: 'pointer',\n  },\n  tocButtonExpanded: {\n    background: '#f2f2f2',\n  },\n  tocButtonBar: {\n    position: 'absolute',\n    width: '60%',\n    background: '#ccc',\n    height: 2,\n    left: '50%',\n    margin: '-1px -30%',\n    top: '50%',\n    transition: 'all .5s ease',\n  },\n  tocButtonBarTop: {\n    top: '35%',\n  },\n  tocButtonBottom: {\n    top: '66%',\n  },\n  loadingView: {\n    position: 'absolute',\n    top: '50%',\n    left: '10%',\n    right: '10%',\n    color: '#ccc',\n    textAlign: 'center',\n    marginTop: '-.5em',\n  },\n}\n","import React, { type CSSProperties, PureComponent, type ReactNode } from 'react'\nimport {\n  type SwipeableProps,\n  type SwipeEventData,\n  useSwipeable,\n} from 'react-swipeable'\nimport { EpubView, type IEpubViewStyle, type IEpubViewProps } from '..'\nimport {\n  ReactReaderStyle as defaultStyles,\n  type IReactReaderStyle,\n} from './style'\nimport { type NavItem } from 'epubjs'\n\ntype SwipeWrapperProps = {\n  children: ReactNode\n  swipeProps: Partial<SwipeableProps>\n}\n\nconst SwipeWrapper = ({ children, swipeProps }: SwipeWrapperProps) => {\n  const handlers = useSwipeable(swipeProps)\n  return (\n    <div style={{ height: '100%' }} {...handlers}>\n      {children}\n    </div>\n  )\n}\n\ntype TocItemProps = {\n  data: NavItem\n  setLocation: (value: string) => void\n  styles?: CSSProperties\n}\n\nconst TocItem = ({ data, setLocation, styles }: TocItemProps) => (\n  <div>\n    <button onClick={() => setLocation(data.href)} style={styles}>\n      {data.label}\n    </button>\n    {data.subitems && data.subitems.length > 0 && (\n      <div style={{ paddingLeft: 10 }}>\n        {data.subitems.map((item, i) => (\n          <TocItem\n            key={i}\n            data={item}\n            styles={styles}\n            setLocation={setLocation}\n          />\n        ))}\n      </div>\n    )}\n  </div>\n)\n\nexport type IReactReaderProps = IEpubViewProps & {\n  title?: string\n  showToc?: boolean\n  readerStyles?: IReactReaderStyle\n  epubViewStyles?: IEpubViewStyle\n  swipeable?: boolean\n  isRTL?: boolean\n  pageTurnOnScroll?: boolean\n  searchQuery?: string\n  contextLength?: number\n  onSearchResults?: (results: SearchResult[]) => void\n}\n\ntype SearchResult = { cfi: string; excerpt: string }\n\ntype IReactReaderState = {\n  isLoaded: boolean\n  expandedToc: boolean\n  toc: NavItem[]\n}\n\nexport class ReactReader extends PureComponent<\n  IReactReaderProps,\n  IReactReaderState\n> {\n  state: Readonly<IReactReaderState> = {\n    isLoaded: false,\n    expandedToc: false,\n    toc: [],\n  }\n  readerRef = React.createRef<EpubView>()\n  constructor(props: IReactReaderProps) {\n    super(props)\n  }\n  toggleToc = () => {\n    this.setState({\n      expandedToc: !this.state.expandedToc,\n    })\n  }\n\n  next = () => {\n    const node = this.readerRef.current\n    if (node && node.nextPage) {\n      node.nextPage()\n    }\n  }\n\n  prev = () => {\n    const node = this.readerRef.current\n    if (node && node.prevPage) {\n      node.prevPage()\n    }\n  }\n\n  onTocChange = (toc: NavItem[]) => {\n    const { tocChanged } = this.props\n    this.setState(\n      {\n        toc: toc,\n      },\n      () => tocChanged && tocChanged(toc)\n    )\n  }\n\n  renderToc() {\n    const { toc, expandedToc } = this.state\n    const { readerStyles = defaultStyles } = this.props\n    return (\n      <div>\n        <div style={readerStyles.tocArea}>\n          <div style={readerStyles.toc}>\n            {toc.map((item, i) => (\n              <TocItem\n                data={item}\n                key={i}\n                setLocation={this.setLocation}\n                styles={readerStyles.tocAreaButton}\n              />\n            ))}\n          </div>\n        </div>\n        {expandedToc && (\n          <div style={readerStyles.tocBackground} onClick={this.toggleToc} />\n        )}\n      </div>\n    )\n  }\n\n  setLocation = (loc: string) => {\n    const { locationChanged } = this.props\n    this.setState(\n      {\n        expandedToc: false,\n      },\n      () => locationChanged && locationChanged(loc)\n    )\n  }\n\n  renderTocToggle() {\n    const { expandedToc } = this.state\n    const { readerStyles = defaultStyles } = this.props\n    return (\n      <button\n        style={Object.assign(\n          {},\n          readerStyles.tocButton,\n          expandedToc ? readerStyles.tocButtonExpanded : {}\n        )}\n        onClick={this.toggleToc}\n      >\n        <span\n          style={Object.assign(\n            {},\n            readerStyles.tocButtonBar,\n            readerStyles.tocButtonBarTop\n          )}\n        />\n        <span\n          style={Object.assign(\n            {},\n            readerStyles.tocButtonBar,\n            readerStyles.tocButtonBottom\n          )}\n        />\n      </button>\n    )\n  }\n\n  // Changing Page based on direction of scroll\n  handleWheel = (event: WheelEvent) => {\n    event.preventDefault()\n\n    const node = this.readerRef.current\n    if (!node) return\n\n    if (event.deltaY > 0) {\n      node.nextPage?.()\n    } else if (event.deltaY < 0) {\n      node.prevPage?.()\n    }\n  }\n\n  // Setting up event listener in the iframe of the viewer\n  attachWheelListener = () => {\n    if (!this.readerRef.current) return\n\n    const rendition = this.readerRef.current.rendition\n\n    if (rendition) {\n      rendition.hooks.content.register(\n        (contents: { window: { document: any } }) => {\n          const iframeDoc = contents.window.document\n\n          // Remove any existing listener before adding a new one\n          iframeDoc.removeEventListener('wheel', this.handleWheel)\n          iframeDoc.addEventListener('wheel', this.handleWheel, {\n            passive: false,\n          })\n        }\n      )\n    }\n  }\n\n  //search function to find all occurence and set amount of charecters for context\n  searchInBook = async (query?: string) => {\n    if (!this.readerRef.current) return\n    const rendition = this.readerRef.current?.rendition\n    const book = rendition?.book\n    if (!book) return\n\n    if (!query) {\n      this.props.onSearchResults?.([])\n      return\n    }\n\n    await book.ready\n    const results: SearchResult[] = []\n    const promises: Promise<void>[] = []\n\n    book.spine.each((item: any) => {\n      if (query == '' || query == null) results\n      const promise = (async () => {\n        try {\n          await item.load(book.load.bind(book))\n          const doc = item.document\n          const textNodes: Node[] = []\n\n          const treeWalker = doc.createTreeWalker(\n            doc,\n            NodeFilter.SHOW_TEXT,\n            null,\n            false\n          )\n          let node\n          while ((node = treeWalker.nextNode())) {\n            textNodes.push(node)\n          }\n\n          const fullText = textNodes\n            .map((n) => n.textContent)\n            .join('')\n            .toLowerCase()\n          const searchQuery = query.toLowerCase()\n          let pos = fullText.indexOf(searchQuery)\n\n          while (pos !== -1) {\n            let nodeIndex = 0\n            let foundOffset = pos\n\n            while (nodeIndex < textNodes.length) {\n              const nodeText = textNodes[nodeIndex].textContent || ''\n              if (foundOffset < nodeText.length) break\n              foundOffset -= nodeText.length\n              nodeIndex++\n            }\n\n            if (nodeIndex < textNodes.length) {\n              let range = doc.createRange()\n              try {\n                range.setStart(textNodes[nodeIndex], foundOffset)\n                range.setEnd(\n                  textNodes[nodeIndex],\n                  foundOffset + searchQuery.length\n                )\n                const cfi = item.cfiFromRange(range)\n                const excerpt = `${fullText.substring(\n                  Math.max(0, pos - (this.props.contextLength || 15)),\n                  pos + searchQuery.length + (this.props.contextLength || 15)\n                )}`\n\n                results.push({ cfi, excerpt })\n              } catch (e) {\n                console.warn('Skipping invalid range:', e)\n              }\n            }\n\n            pos = fullText.indexOf(searchQuery, pos + 1)\n          }\n\n          item.unload()\n        } catch (error) {\n          console.error('Error searching chapter:', error)\n        }\n      })()\n      promises.push(promise)\n    })\n\n    await Promise.all(promises)\n    //Fix for Search Result of previous query retaining when\n    if (query == this.props.searchQuery) {\n      this.props.onSearchResults?.(results) //passing result as an array of objects with cfi and excerpt\n    }\n  }\n\n  //Actions to perform when the component updates\n  componentDidUpdate(prevProps: IReactReaderProps) {\n    //searching only when new search query is passed\n    if (prevProps.searchQuery !== this.props.searchQuery) {\n      this.searchInBook(this.props.searchQuery)\n    }\n\n    //attaching the wheel listner only when pageTurnOnScroll is set as true\n    if (this.props.pageTurnOnScroll === true) {\n      this.attachWheelListener()\n    }\n  }\n\n  render() {\n    const {\n      title,\n      showToc = true,\n      loadingView,\n      readerStyles = defaultStyles,\n      locationChanged,\n      swipeable,\n      epubViewStyles,\n      isRTL = false,\n      pageTurnOnScroll = false,\n      searchQuery,\n      contextLength,\n      ...props\n    } = this.props\n    const { toc, expandedToc } = this.state\n    return (\n      <div style={readerStyles.container}>\n        <div\n          style={Object.assign(\n            {},\n            readerStyles.readerArea,\n            expandedToc ? readerStyles.containerExpanded : {}\n          )}\n        >\n          {showToc && this.renderTocToggle()}\n          <div style={readerStyles.titleArea}>{title}</div>\n          <SwipeWrapper\n            swipeProps={{\n              onSwiped: (eventData: SwipeEventData) => {\n                const { dir } = eventData\n                if (dir === 'Left') {\n                  isRTL ? this.prev() : this.next()\n                }\n                if (dir === 'Right') {\n                  isRTL ? this.next() : this.prev()\n                }\n              },\n              onTouchStartOrOnMouseDown: ({ event }) => event.preventDefault(),\n              touchEventOptions: { passive: false },\n              preventScrollOnSwipe: true,\n              trackMouse: true,\n            }}\n          >\n            <div style={readerStyles.reader}>\n              <EpubView\n                ref={this.readerRef}\n                loadingView={\n                  loadingView === undefined ? (\n                    <div style={readerStyles.loadingView}>Loading…</div>\n                  ) : (\n                    loadingView\n                  )\n                }\n                epubViewStyles={epubViewStyles}\n                {...props}\n                tocChanged={this.onTocChange}\n                locationChanged={locationChanged}\n              />\n              {swipeable && <div style={readerStyles.swipeWrapper} />}\n            </div>\n          </SwipeWrapper>\n          <button\n            style={Object.assign({}, readerStyles.arrow, readerStyles.prev)}\n            onClick={isRTL ? this.next : this.prev}\n          >\n            ‹\n          </button>\n          <button\n            style={Object.assign({}, readerStyles.arrow, readerStyles.next)}\n            onClick={isRTL ? this.prev : this.next}\n          >\n            ›\n          </button>\n        </div>\n        {showToc && toc && this.renderToc()}\n      </div>\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}